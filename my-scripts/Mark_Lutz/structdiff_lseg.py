json1 = {
   "schemes":[
      {
         "id":"scheme:autoqaSchemeLQtiy",
         "concepts":[
            {
               "id":"autoqaSchemeLQtiy:300",
               "uri":{
                  "value":"https://graph.link/risk/schema/QAConcept",
                  "action":"create",
                  "effectiveTo":"2024-09-01 06:09:19.551",
                  "effectiveFrom":"2021-09-01 06:09:19.551"
               },
               "names":[
                  {
                     "role":"wcMdNameRole:main",
                     "value":"This is Main Name of draft record.",
                     "action":"create",
                     "language":"en-GB",
                     "effectiveTo":"2024-09-01 06:09:19.551",
                     "effectiveFrom":"2021-09-01 06:09:19.551"
                  },
                  {
                     "role":"wcMdNameRole:ISO_NAME",
                     "value":"This is ISO Name of draft record.",
                     "action":"create",
                     "language":"en-GB",
                     "effectiveTo":"2024-09-01 06:09:19.551",
                     "effectiveFrom":"2021-09-01 06:09:19.551"
                  },
                  {
                     "role":"wcMdNameRole:ALTE_NAME",
                     "value":"This is alternate Name of draft record.",
                     "action":"create",
                     "language":"en-GB",
                     "effectiveTo":"2024-09-01 06:09:19.551",
                     "effectiveFrom":"2021-09-01 06:09:19.551"
                  }
               ],
               "notes":[
                  {
                     "role":"wcMdNoteRole:main",
                     "value":"This is main test note of draft record.",
                     "action":"create",
                     "language":"en-GB",
                     "effectiveTo":"2024-09-01 06:09:19.551",
                     "effectiveFrom":"2021-09-01 06:09:19.551",
                     "intWCIsInternal":True
                  }
               ],
               "action":"create",
               "status":{
                  "value":"wcMdStatus:DRAFT"
               },
               "relateds":[
                  {
                     "id":"automationTestData",
                     "rel":"relation:rel",
                     "uri":"Relation URI",
                     "value":"Relation Value",
                     "action":"create",
                     "relateds":[
                        {
                           "id":"automationTestData",
                           "rel":"nestedRelation:rel",
                           "uri":"Nested Relation Uri",
                           "value":"nested Relation Value",
                           "action":"create",
                           "valueUnit":"Nested Relation Value Unit",
                           "entityType":"nested related entityType",
                           "effectiveTo":"2024-09-01 06:09:19.551",
                           "effectiveFrom":"2021-09-01 06:09:19.551",
                           "valueDataType":"STRING",
                           "intWCIsInternal":True
                        }
                     ],
                     "valueUnit":"Relation Value Unit",
                     "entityType":"automationTestData",
                     "effectiveTo":"2024-09-01 06:09:19.551",
                     "effectiveFrom":"2021-09-01 06:09:19.551",
                     "valueDataType":"STRING",
                     "intWCIsInternal":True
                  }
               ],
               "entityType":{
                  "value":"This is the entityType of Draft",
                  "action":"create",
                  "effectiveTo":"2024-09-01 06:09:19.551",
                  "effectiveFrom":"2021-09-01 06:09:19.551"
               },
               "definitions":[
                  {
                     "role":"wcMdDefRole:main",
                     "value":"This is test definitions of draft record.",
                     "action":"create",
                     "language":"en-GB",
                     "effectiveTo":"2024-09-01 06:09:19.551",
                     "effectiveFrom":"2021-09-01 06:09:19.551"
                  }
               ],
               "effectiveTo":"2024-09-01 06:09:19.551",
               "effectiveFrom":"2021-09-01 06:09:19.551",
               "intWCInternal":{
                  "createdBy":"1003129",
                  "processId":1665715813,
                  "lastDraftEditor":"1003129"
               },
               "intWCIsInternal":True
            }
         ]
      }
   ]
}


json2 = {
   "schemes":[
      {
         "id":"scheme:autoqaSchemeLQtiy",
         "concepts":[
            {
               "id":"autoqaSchemeLQtiy:300",
               "uri":{
                  "value":"https://graph.link/risk/schema/QAConcept",
                  "action":"create",
                  "effectiveTo":"2024-09-01 06:09:19.551",
                  "effectiveFrom":"2021-09-01 06:09:19.551"
               },
               "names":[
                  {
                     "role":"wcMdNameRole:main",
                     "value":"This is Main Name of draft record.",
                     "action":"create",
                     "language":"en-GB",
                     "effectiveTo":"2024-09-01 06:09:19.551",
                     "effectiveFrom":"2021-09-01 06:09:19.551"
                  },
                  {
                     "role":"wcMdNameRole:ISO_NAME",
                     "value":"This is ISO Name of new draft record.",
                     "action":"create",
                     "language":"en-GB",
                     "effectiveTo":"2024-09-01 06:09:19.551",
                     "effectiveFrom":"2021-09-01 06:09:19.551"
                  },
               ],
               "notes":[
                  {
                     "role":"wcMdNoteRole:main",
                     "value":"This is main test note of draft record.",
                     "action":"create",
                     "language":"en-GB",
                     "effectiveTo":"2024-09-01 06:09:19.551",
                     "effectiveFrom":"2021-09-01 06:09:19.551",
                     "intWCIsInternal":True
                  }
               ],
               "action":"create",
               "status":{
                  "value":"wcMdStatus:DRAFT"
               },
               "relateds":[
                  {
                     "id":"automationTestData",
                     "rel":"relation:rel",
                     "uri":"Relation URI",
                     "value":"Relation Value",
                     "action":"create",
                     "relateds":[
                        {
                           "id":"automationTestData",
                           "rel":"nestedRelation:rel",
                           "uri":"Nested Relation Uri",
                           "value":"nested Relation Value",
                           "action":"create",
                           "valueUnit":"Nested Relation Value Unit",
                           "entityType":"nested related entityType",
                           "effectiveTo":"2024-09-01 06:09:19.551",
                           "effectiveFrom":"2021-09-01 06:09:19.551",
                           "valueDataType":"STRING",
                           "intWCIsInternal":True
                        }
                     ],
                     "valueUnit":"Relation Value Unit",
                     "entityType":"automationTestData",
                     "effectiveTo":"2024-09-01 06:09:19.551",
                     "effectiveFrom":"2021-09-01 06:09:19.551",
                     "valueDataType":"STRING",
                     "intWCIsInternal":True
                  }
               ],
               "entityType":{
                  "value":"This is the entityType of Draft",
                  "action":"create",
                  "effectiveTo":"2024-09-01 06:09:19.551",
                  "effectiveFrom":"2021-09-01 06:09:19.551"
               },
               "definitions":[
                  {
                     "role":"wcMdDefRole:main",
                     "value":"This is test definitions of draft record.",
                     "action":"create",
                     "language":"en-GB",
                     "effectiveTo":"2024-09-01 06:09:19.551",
                     "effectiveFrom":"2021-09-01 06:09:19.551"
                  }
               ],
               "effectiveTo":"2024-09-01 06:09:19.551",
               "effectiveFrom":"2021-09-01 06:09:19.551",
               "intWCInternal":{
                  "createdBy":"1003129",
                  "processId":1665715813,
                  "lastDraftEditor":"1003129"
               },
               "intWCIsInternal":True
            }
         ]
      }
   ]
}

import ast

class StructDiff:


    def __init__(self,source,target):
        self.source = source
        self.target = target

    @staticmethod
    def get_paths(struct):
        paths = []
        if isinstance(struct, dict):  # found a dict-like structure...
            for k, v in struct.items():  # iterate over it
                paths.append([k])  # add the current child path
                paths += [[k] + x for x in StructDiff.get_paths(v)]  # get sub-paths, extend with the current

        # else, check if a list-like structure, remove if you don't want list paths included
        elif isinstance(struct, list) and not isinstance(struct, str):
            for i, v in enumerate(struct):
                paths.append([i])
                paths += [[i] + x for x in StructDiff.get_paths(v)]  # get sub-paths, extend with the current
        return paths
    
    @staticmethod
    def get_struct(struct_file):
        with open(struct_file) as f:
            return ast.literal_eval(f.read())

    @classmethod
    def from_file(cls,source_file,target_file):
        return cls(cls.get_struct(source_file),cls.get_struct(target_file))        

    ##Getting value of any path(in form of list) from any structure type
    @staticmethod
    def deref_multi(data, keys):
        return StructDiff.deref_multi(data[keys[0]], keys[1:]) if keys else data

    def compare(self):
        ##getting all desired paths of any given structure
        source_paths,target_paths = self.__class__.get_paths(self.source),self.__class__.get_paths(self.target)

        matched = None
        num = 0

        ##Looping over structure
        while num < len(source_paths):

            ##Indentying missing path
            if source_paths[num] not in target_paths:
                print("MISSING JPATH IN TARGET,{}".format('.'.join(str(v) for v in source_paths[num])))
                num = num + 1
                continue

            ##If parent path matched, then not matching child paths - saving memory/time
            if source_paths[num][0] == matched:
                num=num+1
                continue

            ##If parent path
            if len(source_paths[num]) == 1:
                source,target = self.source[source_paths[num][0]], self.target[source_paths[num][0]]
                if(source == target): ##if values in both structure matches
                    matched = source_paths[num][0]
                
                ##if parent not matches, last parent node(single by dfault) or checking if its single parent  
                elif num == len(source_paths)-1 or source_paths[num][0] != source_paths[num+1][0]:
                #elif isinstance(source,(int,str)) or isinstance(target,(int,str)):
                    print('MISMATCH,{},{},{}'.format('.'.join(source_paths[num]),source,target))
            else:
                current_jpath = '.'.join(str(v) for v in source_paths[num])
                next_jpath = '.'.join(str(v) for v in source_paths[num+1][:-1]) if num < len(source_paths)-1 else None

                if current_jpath != next_jpath:
                    source,target = StructDiff.deref_multi(self.source,source_paths[num]),StructDiff.deref_multi(self.target,source_paths[num])
                    if source != target:
                        print('MISMATCH,{},{},{}'.format(current_jpath,source,target))

            num = num + 1

        for path in target_paths:
            if path not in source_paths:
                print("MISSING JPATH IN SOURCE,{}".format('.'.join(str(v) for v in path)))

if __name__ == '__main__':
    cmp_obj = StructDiff(json1,json2)
    #cmp_obj = StructDiff.from_file('json1.pkl','json2.pkl')
    #print(cmp_obj)
    cmp_obj.compare()

'''
['global_information']
['global_information', 'organization_information']
['global_information', 'organization_information', 'classifications']
['global_information', 'organization_information', 'classifications', 'primary_naics_code']
['global_information', 'organization_information', 'classifications', 'sic_code']
['global_information', 'country_information']
['global_information', 'country_information', 'instrument_country_information']
['global_information', 'country_information', 'instrument_country_information', 'country_code']
['global_information', 'country_information', 'instrument_country_information', 'holiday_schedule']
['master_information']
['master_information', 'instrument_master']
['master_information', 'instrument_master', 'apex_asset_type_descr']
['master_information', 'instrument_master', 'federal_tax_status_descr']
['master_information', 'instrument_master', 'primary_exchange']
['master_information', 'instrument_master', 'primary_currency_code']
['master_information', 'instrument_master', 'accrued_interest']
['master_information', 'instrument_master', 'accrued_interest', 'ex_div_date_ind']
['master_information', 'instrument_master', 'instrument_type_descr']
['instrument_id']
'''
#from jsondiff import diff
#print(diff(json1, json2))
